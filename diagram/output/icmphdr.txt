protocol name: IcmpLayer;
icmphdr
pragma pack(push, 1)
	typedef struct icmphdr
	{
		/** message type */
		uint8_t	 type;
		/** message code */
		uint8_t	 code;
		/** message checksum */
		uint16_t checksum;
	} icmphdr;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_echo_hdr : icmphdr
	{
		/** the echo (ping) request identifier */
		uint16_t id;
		/** the echo (ping) request sequence number */
		uint16_t sequence;
		/** a timestamp of when the message was sent */
		uint64_t timestamp;
	} icmp_echo_hdr;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_timestamp_request : icmphdr
	{
		/** the timestamp request identifier */
		uint16_t id;
		/** the timestamp request sequence number */
		uint16_t sequence;
		/** the time (in milliseconds since midnight) the sender last touched the packet */
		uint32_t originateTimestamp;
		/** relevant for timestamp reply only - the time the echoer first touched it on receipt */
		uint32_t receiveTimestamp;
		/** relevant for timestamp reply only - the time the echoer last touched the message on sending it */
		uint32_t transmitTimestamp;
	} icmp_timestamp_request;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_destination_unreachable : icmphdr
	{
		/** unused 2 bytes */
		uint16_t unused;
		/** contains the MTU of the next-hop network if a code 4 error occurs */
		uint16_t nextHopMTU;
	} icmp_destination_unreachable;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_time_exceeded : icmphdr
	{
		/** unused 4 bytes */
		uint32_t unused;
	} icmp_time_exceeded;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_param_problem : icmphdr
	{
		/** in the case of an invalid IP header (Code 0), this field indicates the byte offset of the error in the header */
		uint8_t  pointer;
		/** unused 1 byte */
		uint8_t  unused1;
		/** unused 2 bytes */
		uint16_t unused2;
	} icmp_param_problem;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_redirect : icmphdr
	{
		/** an IPv4 address of the gateway to which the redirection should be sent */
		uint32_t gatewayAddress;
	} icmp_redirect;
#pragma pack
pragma pack(push, 1)
	struct icmp_router_address_structure
	{
		/** the IPv4 address of the advertised router */
		uint32_t routerAddress;
		/** The preferability of the router address as a default router address, relative to other router addresses
		 * on the same subnet. This is a twos-complement value where higher values indicate that the route is
		 * more preferable */
		uint32_t preferenceLevel;

		/**
		 * Set router address structure from a given IPv4 address and preference level
		 * @param[in] addr IPv4 address to set
		 * @param[in] preference Preference level to set
		 */
		void setRouterAddress(IPv4Address addr, uint32_t preference);

		/**
		 * @return The IPv4 address extracted from icmp_router_address_structure#routerAddress field
		 */
		IPv4Address getAddress() const { return routerAddress; }
	};
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_router_advertisement_hdr : icmphdr
	{
		/** the number of router advertisements in this message. Each advertisement contains one router address/preference level pair */
		uint8_t  advertisementCount;
		/** the number of 32-bit words of information for each router address entry in the list. The value is normally set to 2
		 * (router address + preference level) */
		uint8_t  addressEntrySize;
		/** the maximum number of seconds that the router addresses in this list may be considered valid */
		uint16_t lifetime;
	} icmp_router_advertisement_hdr;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_address_mask_request : icmphdr
	{
		/** the address mask request identifier */
		uint16_t id;
		/** the address mask request sequence */
		uint16_t sequence;
		/** the subnet mask of the requesting host */
		uint32_t addressMask;
	} icmp_address_mask_request;
#pragma pack
pragma pack(push, 1)
	typedef struct icmp_info_request : icmphdr
	{
		/** the information request identifier */
		uint16_t id;
		/** the information request sequence */
		uint16_t sequence;
	} icmp_info_request;
#pragma pack
